# pu-239

**pu-239** is a Rust crate that allows you to write server-side functions directly within your client-side code. It simplifies client-server communication by automating the serialization and transmission of function calls and their responses.

## Features

- **Server-Side Function Declaration**: Use a simple macro to declare server-side functions in client code.
- **Automatic Serialization**: Handles serialization and deserialization of arguments and return values.
- **Async Support**: Fully supports asynchronous functions.

## Usage

Add `pu-239` to your `Cargo.toml`:

```toml
[dependencies]
pu-239 = "0.2.0"
```

### Defining Server-Side Functions in Client Code

In your client code, annotate functions with `#[pu_239::server]`. These functions will be transformed to handle communication with the server.

```rust
#[pu_239::server]
pub async fn some_serverside_fn(arg: ArgType) -> ReturnType {
    // The macro will replace the body with code to call the server.
}
```

### Implementing Functions on the Server

On the server, provide the actual implementations of the functions with the same signatures.

```rust
#[pu_239::server]
pub async fn some_serverside_fn(arg: ArgType) -> ReturnType {
    // Server-side logic goes here.
}
```

### Generating the Server API Dispatcher

Use the `pu_239::build_api!` macro to generate dispatch code based on your client modules.

```rust
pu_239::build_api!(["path/to/client/lib.rs", "path/to/other_module.rs"]);

pub async fn api_handler(req: web::Bytes) -> actix_web::HttpResponse {
    let mut bytes = actix_web::web::Buf::reader(req);
    match deserialize_api_match(&mut bytes).await {
        Ok(response) => actix_web::HttpResponse::Ok().body(response),
        Err(e) => actix_web::HttpResponse::InternalServerError().body(format!("{e:?}")),
    }
}
```

### Calling Functions from Client Code

Call the server-side functions from your client code as if they were local `async` functions.

```rust
let result = some_serverside_fn(some_arg).await;
```

## Example

**Client-Side Declaration:**

```rust
#[pu_239::server]
pub async fn get_data(id: u64) -> DataType {
    // Body is generated by the macro.
}
```

**Server-Side Implementation:**

```rust
#[pu_239::server]
pub async fn get_data(id: u64) -> DataType {
    // Fetch data from the database or perform other server-side operations.
}
```

**Server Dispatch Setup:**

```rust
pu_239::build_api!(["src/client/lib.rs"]);

pub async fn api_handler(req: web::Bytes) -> actix_web::HttpResponse {
    let mut bytes = actix_web::web::Buf::reader(req);
    match deserialize_api_match(&mut bytes).await {
        Ok(response) => actix_web::HttpResponse::Ok().body(response),
        Err(e) => actix_web::HttpResponse::InternalServerError().body(format!("{e:?}")),
    }
}
```

## How It Works

- The `#[pu_239::server]` macro on the client transforms the function into a stub that serializes the arguments and sends them to the server.
- On the server, the same macro helps in registering the function so that it can be called when a request is received.
- The `pu_239::build_api!` macro generates the necessary code to dispatch incoming requests to the appropriate server-side functions.

## License

This project is licensed under the MIT License.
